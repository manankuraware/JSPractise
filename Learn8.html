<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Event bubbling</title>
  </head>

  <body>
    <!-- Event bubbling describes how the browser handles events targeted at nested elements. -->
    <!-- What happens if we add event listeners to the button and the parent? -->
    <!-- <div id="container">
      <button>Click me!</button>
    </div>
    <pre id="output"></pre> -->
    <!-- <button>Display video</button>

    <div class="hidden">
      <video>
        <source
          src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm"
          type="video/webm"
        />
        <p>
          Your browser doesn't support HTML video. Here is a
          <a href="rabbit320.mp4">link to the video</a> instead.
        </p>
      </video>
    </div> -->
<!-- 
    Event delegation: In the last section, we looked at a problem caused by event
    bubbling and how to fix it. Event bubbling isn't just annoying, though: it
    can be very useful. In particular, it enables event delegation. In this
    practice, when we want some code to run when the user interacts with any one
    of a large number of child elements, we set the event listener on their
    parent and have events that happen on them bubble up to their parent rather
    than having to set the event listener on every child individually. -->

    <body>
      <div id="container">
        <button>Click me!</button>
      </div>
      <pre id="output"></pre>
    </body>

    <script>
      //  stopPropagation() which, when called inside an event handler, prevents the event from bubbling up to any other elements.
      //   const btn = document.querySelector("button");
      //   const box = document.querySelector("div");
      //   const video = document.querySelector("video");

      //   btn.addEventListener("click", () => box.classList.remove("hidden"));

      //   video.addEventListener("click", (event) => {
      //     event.stopPropagation();
      //     video.play();
      //   });
      //   box.addEventListener("click", () => box.classList.add("hidden"));

      //   An alternative form of event propagation is event capture. This is like event bubbling but the order is reversed:
      //   so instead of the event firing first on the innermost element targeted, and then on successively less nested elements,
      //   the event fires first on the least nested element, and then on successively more nested elements, until the target is reached.
      //   Event capture is disabled by default. To enable it you have to pass the capture option in addEventListener().
      const output = document.querySelector("#output");
      function handleClick(e) {
        output.textContent += `You clicked on a ${e.currentTarget.tagName} element\n`;
      }
      const container = document.querySelector("#container");
      const button = document.querySelector("button");
      document.body.addEventListener("click", handleClick, { capture: true });
      container.addEventListener("click", handleClick, { capture: true });
      button.addEventListener("click", handleClick);
    </script>
  </body>
</html>
